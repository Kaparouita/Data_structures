// ASK1.a
/*Xronikh polyplokothta O(n) afou prepei na episkeftoume n komvous
  Xwrikh  polyplokothta O(h) opou h to upsos tou dentrou */
Node *clone(Node *root)
{
    if (root == NULL)
        return NULL;
    // copy the root
    Node *new_root = (Node *)malloc(sizeof(Node));
    new_root->val = root->val;
    // anadromika copy ta left kai right
    new_root->left = clone(root->left);
    new_root->right = clone(root->right);

    return new_root;
}

//ASK1.b

// update childrens
treenode *tranform(Node *root)
{
    if (root == NULL)
        return NULL;
    treenode *new_node = (treenode *)malloc(sizeof(treenode));
    new_node->val = root->val;
    new_node->k = root.k;
    new_node->k = 0;
    // child
    Node *P = root->left;
    while (P != NULL)
    {
        treenode *new_child = (treenode *)malloc(sizeof(treenode));
        new_child->val = P->val;

        // Add the child
        new_node->children[new_node->k] = new_child;

        printf("Parent val :%d ,", root->val);
        printf("Child %d :%d\n", new_node->k, new_node->children[new_node->k]->val);

        // update the size
        new_node->k = (new_node->k + 1);
        P = P->right;
    }
    return new_node;
}

/*Time complexity O(n) afou diasxizw olo to tree
 Space complexity O(n) afou kanw copy ena tree*/
treenode *tranformTree(Node *R)
{
    int i = 0;
    if (R == NULL)
        return NULL;
    // kanw init ta paidia tou
    treenode *node = tranform(R);
    // proxwraw to root sta paidia
    R = R->left;
    while (R != NULL)
    {
        // to kanw sto prwto paidi
        node->children[i] = tranformTree(R);
        // gia kathe paidi
        R = R->right;
        i++;
    }
    return node;
}

//ASK2.a
/*find depth given root and key of the node iam looking for*/
int NodeDepth(Node *root, int key, int depth)
{
    int left, right;
    if (root == NULL)
        return 0;
    /*otan vreis to val kane return*/
    if (root->val == key)
        return depth;
    /*tsekare aristera*/
    left = NodeDepth(root->left, key, depth + 1);
    if (left != 0)
        return left;

    right = NodeDepth(root->right, key, depth + 1);
    if (right != 0)
        return right;

    return 0;
}
/*find height of a node*/
int Nodeheight(Node *root)
{
    int l, r;
    if (root == NULL)
        return -1;
    l = Nodeheight(root->left);
    r = Nodeheight(root->right);

    if (l > r)
        return (l + 1);
    else
        return (r + 1);
}
/**
 * @brief find out if there is a node witch height==depth
 *
 * @param root
 * @return 1 if true else 0
 */
int DepthEqualHeight(Node *cur_root, Node *root)
{
    if (cur_root == NULL)
        return 0;
    if (NodeDepth(root, cur_root->val, 0) == Nodeheight(cur_root))
    {
        printf("%d\n", cur_root->val);
        printf("%d  %d\n", Nodeheight(cur_root), NodeDepth(root, cur_root->val, 0));
        return 1;
    }
    return DepthEqualHeight(cur_root->left, root) || DepthEqualHeight(cur_root->right, root);
}

//ASK2.b
void treenodeRight(treenode *root){
  int i=0;
  if(root==NULL)
     return;
   i=root->k-1;
   while(i>=0){
      printf("%d ,",root->children[i]->val);
      i--;
   }  
   i=root->k-1;
   while(i>=0){
     treenodeRight(root->children[i]);
     i--;
   }  
}